/**
 * Prompt Bundler Script
 *
 * Bundles markdown prompt files into a TypeScript module for browser usage.
 * This allows prompts to be embedded in the browser bundle without needing
 * runtime file access.
 *
 * Usage: npx tsx scripts/bundle-prompts.ts
 */

import { readFileSync, writeFileSync, readdirSync, statSync, mkdirSync, existsSync } from 'fs';
import { join, relative, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Recursively collect all markdown files from a directory
 */
function collectPrompts(dir: string, base: string): Record<string, string> {
  const prompts: Record<string, string> = {};

  if (!existsSync(dir)) {
    console.warn(`Directory not found: ${dir}`);
    return prompts;
  }

  for (const entry of readdirSync(dir)) {
    const fullPath = join(dir, entry);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      Object.assign(prompts, collectPrompts(fullPath, base));
    } else if (entry.endsWith('.md')) {
      // Create a relative key path
      const key = relative(base, fullPath).replace(/\\/g, '/');
      try {
        const content = readFileSync(fullPath, 'utf-8');
        prompts[key] = content;
        console.log(`  Bundled: ${key} (${content.length} chars)`);
      } catch (error) {
        console.error(`  Error reading ${fullPath}:`, error);
      }
    }
  }

  return prompts;
}

/**
 * Escape a string for use in a JavaScript template literal
 */
function escapeTemplateString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\${/g, '\\${');
}

/**
 * Main bundling function
 */
function bundlePrompts(): void {
  console.log('Bundling prompts...\n');

  // Paths
  const promptsDir = join(__dirname, '../src/prompts/v2');
  const outputDir = join(__dirname, '../src/platform/browser');
  const outputFile = join(outputDir, 'bundled-prompts.ts');

  // Ensure output directory exists
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Collect prompts
  console.log(`Scanning: ${promptsDir}\n`);
  const prompts = collectPrompts(promptsDir, promptsDir);

  const promptCount = Object.keys(prompts).length;
  console.log(`\nFound ${promptCount} prompt files\n`);

  if (promptCount === 0) {
    console.warn('No prompts found! Creating empty bundle.');
  }

  // Generate output
  const entries = Object.entries(prompts).map(([key, value]) => {
    return `  "${key}": \`${escapeTemplateString(value)}\``;
  });

  const output = `/**
 * Bundled Prompts
 *
 * Auto-generated by scripts/bundle-prompts.ts
 * DO NOT EDIT MANUALLY
 *
 * Generated: ${new Date().toISOString()}
 * Total prompts: ${promptCount}
 */

export const BUNDLED_PROMPTS: Record<string, string> = {
${entries.join(',\n')}
};

/**
 * Get a bundled prompt by path
 */
export function getPrompt(path: string): string | undefined {
  // Try exact match
  if (path in BUNDLED_PROMPTS) {
    return BUNDLED_PROMPTS[path];
  }

  // Try with .md extension
  const withMd = path.endsWith('.md') ? path : \`\${path}.md\`;
  if (withMd in BUNDLED_PROMPTS) {
    return BUNDLED_PROMPTS[withMd];
  }

  // Try without leading ./
  const normalized = path.replace(/^\\.?\\//, '');
  if (normalized in BUNDLED_PROMPTS) {
    return BUNDLED_PROMPTS[normalized];
  }

  return undefined;
}

/**
 * List all available prompt paths
 */
export function listPrompts(): string[] {
  return Object.keys(BUNDLED_PROMPTS);
}
`;

  // Write output
  writeFileSync(outputFile, output, 'utf-8');
  console.log(`Written: ${outputFile}`);

  // Calculate approximate size
  const sizeBytes = output.length;
  const sizeKB = (sizeBytes / 1024).toFixed(2);
  console.log(`Bundle size: ${sizeKB} KB`);

  console.log('\nPrompt bundling complete!');
}

// Run bundler
bundlePrompts();
